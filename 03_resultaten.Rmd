# Resultaten

```{r include=FALSE}
source("./code/not_functions/libraries.R")
source("./code/functions/f.read_excel_allsheets.R")
source("./code/functions/f.dominant.species.R")
source("./code/functions/f.transformation.R")
source("./code/functions/f.dispersie.R")
source("./code/functions/f.pairwise.adonis.R")
source("./code/functions/f.plot.habitat.spatial.R")
source("./code/functions/f.clean_ijzer_and_va.R")
source("./code/functions/f.clean_KGO.R")
```

## Aangepast spuibeheer ter hoogte van de zout-zoetovergangen aan de Belgische kust – effect op de intrek van glasaal

```{r}
clean_AKLLK <- function(file){
  AKLLK <- f.read_excel_allsheets(file, skip = 5)
  AKLLK <- AKLLK[[1]]
  AKLLK <- AKLLK[, colSums(is.na(AKLLK)) < nrow(AKLLK)]
  AKL <- AKLLK[, c(1:3)]
  colnames(AKL) = c("datum","open","dicht")
  AKL$site = "AKL"
  LK <- AKLLK[,c(4:6)]
  colnames(LK) = c("datum","open","dicht")
  LK$site = "LK"
  AKLLK <- rbind(AKL,LK)
  AKLLK$open[which(grepl("[0-9]" , AKLLK$open) == FALSE)] = NA
  AKLLK$dicht[which(grepl("[0-9]" , AKLLK$dicht) == FALSE)] = NA
  AKLLK <- AKLLK[-which(is.na(AKLLK$open) == TRUE | is.na(AKLLK$dicht) == TRUE),]
  AKLLK$open <- str_replace(AKLLK$open,"u",":")
  AKLLK$dicht <- str_replace(AKLLK$dicht,"u",":")
  AKLLK$open <- parse_date_time(paste(AKLLK$datum,AKLLK$open), c("ymd HM", "ymd H"))
  AKLLK$dicht <- parse_date_time(paste(AKLLK$datum,AKLLK$dicht), c("ymd HM", "ymd H"))
  AKLLK$datum <- NULL
  return(AKLLK)
}
AKLLK2023 <- clean_AKLLK("./data/spuibeheer/extern/verwerkt_in_excel/os_AKL&LK_2023.xlsx")
AKLLK2024 <- clean_AKLLK("./data/spuibeheer/extern/verwerkt_in_excel/os_AKL&LK_2024.xlsx")
```

```{r}
Ijzer2023 <- clean_ijzer_and_va(file = "./data/spuibeheer/extern/verwerkt_in_excel/os_Ijzer_2023.xlsx",
                   skip = 7,
                   datum = 1,
                   tijd = 2,
                   opmerking = 14,
                   site = "Ijzer")
Ijzer2024 <- clean_ijzer_and_va(file = "./data/spuibeheer/extern/verwerkt_in_excel/os_Ijzer_2024.xlsx",
                   skip = 7,
                   datum = 1,
                   tijd = 2,
                   opmerking = 14,
                   site = "Ijzer")
VA2023 <- clean_ijzer_and_va(file = "./data/spuibeheer/extern/verwerkt_in_excel/os_VA_2023.xlsx",
                   skip = 6,
                   datum = 1,
                   tijd = 2,
                   opmerking = 8,
                   site = "VA")
VA2024 <- clean_ijzer_and_va(file = "./data/spuibeheer/extern/verwerkt_in_excel/os_VA_2024.xlsx",
                   skip = 6,
                   datum = 1,
                   tijd = 2,
                   opmerking = 8,
                   site = "VA")
```

```{r}
KGO2023 <- clean_KGO("./data/spuibeheer/extern/verwerkt_in_excel/os_KGO_2023.xlsx")
KGO2024 <- clean_KGO("./data/spuibeheer/extern/verwerkt_in_excel/os_KGO_2024.xlsx")
```

```{r}
NE <- read.csv("./data/spuibeheer/intern/os_NE_2023_cleaned.csv")[,c(2:4)]
```

```{r}
os <- rbind(AKLLK2023, AKLLK2024, Ijzer2023, Ijzer2024, KGO2023, KGO2024, NE, VA2023, VA2024)
remove(AKLLK2023, AKLLK2024, Ijzer2023, Ijzer2024, KGO2023, KGO2024, NE)
write.csv(os, "./data/spuibeheer/intern/os_cleaned.csv")
```

Op basis van de tijdregistratie van het **aangepast spuibeheer (AS)** van 2023 en 2024 in combinatie met eerder verkregen inzichten in het aantal glasaal dat gebruik maakt van het AS om stroomopwaarts te migreren, kan een inschatting gemaakt worden van het aantal glasalen dat in 2023 en 2024 stroomopwaarts heeft kunnen trekken door de spuiopeningen. Voor het inschatten van het aantal glasalen dat per getijdencyclus stroomopwaarts migreert via de spuisluizen bij AS wordt gebruik gemaakt van volgende studies: De **Ijzer** thv Ganzepoot [@mouton2010; @mouton2013], het **Leopoldkanaal (LK)** thv de voorhaven van Zeebrugge[@buysse2015], het **Afleidingskanaal van de Leie (AKL)** thv de voorhaven van Zeebrugge [@buysse2015], Het **kanaal Gent-Oostende (KGO)** thv Sas Slijkens [@buysse2012] en de **Noordede (NE)** thv Maertensas [@vandamme2020]. Voor het perskanaal **Veurne-Ambacht (VA)** is jaarlijks het effectief aantal ingetrokken glasalen beschikbaar via de gegevens van de twee glasaal goten die opgesteld staan bij het pompgemaal VA [@vandamme2020].

De berekening van het totaal aantal glasalen dat in een bepaald jaar door de spuiopeningen kan passeren tijdens de periode dat AS toegepast wordt, gebeurt door het gemiddeld aantal glasalen dat passeert per AS event te vermenigvuldigen met het aantal AS events per migratieseizoen (met uitzondering van VA waar het totaal aantal optrekkende glasalen in de glasaalgoten in het betreffende jaar wordt weergegeven).

De berekening van het gemiddeld aantal intrekkende glasalen per AS event gebeurde voor KGO, LK, AKL en NE door het gemiddeld aantal intrekkende dieren te berekenen over de verschillende bemonsteringsmomenten van de spuisluis tijdens het glasaalmigratieseizoen van 2012 (KGO), 2014 (LK & AKL), en 2019 (NE). Voor berekening van het aantal intrekkende glasalen per AS event aan de Ijzer werd gebruik gemaakt van het gemiddelde van de bemonsteringsdata uit twee onderzoeksjaren (2010 en 2013), waarbij alle data gebruikt werden waarbij één of twee spuien 20 cm geopend werden.

Door de beperkte data en grote onzekerheden mbt het aantal glasaal dat zich aanmeldt thv de gesloten spuien (zowel wat betreft het verschil tussen de jaren alsook de schommelingen binnen 1 migratieseizoen), laten de resultaten van de studies van de Ijzer, LK, AKL, KGO en NE niet toe om een meer geavanceerde inschatting te maken op basis van variabelen zoals:

-   Het aantal geopende binnenschuiven

-   Het aantal geopende buitenschuiven

-   De opening van de schuiven

-   De duur van het AS event

-   Het debiet

-   Het waterpeil

-   De watertemperatuur

```{r}
# De meest recente studie van de Ijzer [@mouton2013] was relatief uitgebreid en beschouwde meerdere variabelen maar concludeerde ook hier dat de hoeveelheid glasalen die zich aanmeldt te variabel is om de hoeveelheid glasalen die passeert eenduidig in te schatten. Het belang van het aantal dieren voor de schuiven kwam ook tot uiting bij de analyse van het effect dat het aantal open schuiven heeft: Op het eerste zicht bleek er geen effect te zijn van het aantal open schuiven, maar wanneer een onderscheid werd gemaakt tussen AS events met een grote versus kleine densiteit aan glasaal, bleek dat meer schuiven een significant effect had op het aantal glasalen dat passeert. Een meer informatief model zou daarom ofwel het aandeel glasalen dat succesvol passeert als respons moeten gebruiken of het aantal dieren voor de sluis meenemen als interactiefactor. De benodigde data is daarvoor echter niet voorhanden, noch is er een model beschikbaar dat inschat wat het aantal dieren zou zijn dat zich aanmeldt voor de schuiven op basis van beschikbare omgevingsdata zoals windrichting, neerslag en debiet. Voor het gemiddeld aantal glasaal per event werd gebruik gemaakt van het gemiddelde van de bemonsteringen in 2010 (1 schuif open op 10 cm, lineair geëxtrapoleerd naar 2 schuiven open op 20 cm) [@mouton2010] en 2013 (gemiddeld aantal bij 2 schuiven open op 20 cm) [@mouton2013].
```

Door bovengemelde beperkingen blijft de huidige inschatting bijzonder ruw en dient deze met de nodige voorzichtigheid geïnterpreteerd te worden.

De inschattingen geven aan dat in **2023 en 2024 respectievelijk 550.392 en 671.014 glasalen** voordeel hebben ondervonden van het aangepast spuibeheer tijdens hun stroomopwaartse migratie.

```{r}
os$dicht[which(os$open > os$dicht)] <- os$dicht[which(os$open > os$dicht)] + lubridate::days(1)
os$duration <- os$dicht - os$open
os$jaar <- lubridate::year(os$open)
os$datum <- as.Date(os$open)
os$glasaal <- NA
os$glasaal[which(os$site == "AKL")] = mean(c(1351, 976, 5093, 935, 82, 1461, 704, 200))
os$glasaal[which(os$site == "LK")] = mean(c(1351, 976, 5093, 935, 82, 1461, 704, 200)) #metingen van AKL gebruikt
os$glasaal[which(os$site == "Ijzer")] = mean(c(1200, 3242)) #tussen min en max
os$glasaal[which(os$site == "NE")] = mean(c(8, 56,31,1,2167,9,26,309,3750,17,3827,21,69,88,2014,40,300,12,39,9,60))
os$glasaal[which(os$site == "KGO")] = 964.2
```

```{r}
os.summary <- os %>% 
  dplyr::filter(jaar == 2023 & datum < as.POSIXct("2023-05-15 12:00:00", tz = "Europe/Brussels")) %>% 
  group_by(site) %>%
  summarize(start = as.Date(min(open)),
            stop = as.Date(max(dicht)),
            periode = as.numeric(round(stop - start)),
            aantal.dagen.effectief.os = n_distinct(datum),
            events = n(),
            events.per.dag = round(events/aantal.dagen.effectief.os, digits = 2),
            mediaan.duur.per.event = as.numeric(round(median(duration))),
            mediaan.duur.per.dag = round(mediaan.duur.per.event * events.per.dag),
            totale.duur.os = round(as.numeric(sum(duration))),
            glasaal.per.event = round(mean(glasaal)),
            glasaal.totaal = round(sum(glasaal)))
os.summary$glasaal.totaal[which(os.summary$site == "VA")] = "75690*"
os.summary$start <- format(strptime(as.character(as.Date(os.summary$start)), "%Y-%m-%d"), "%d-%m-%Y")
os.summary$stop <- format(strptime(as.character(as.Date(os.summary$stop)), "%Y-%m-%d"), "%d-%m-%Y")
tos.summary <- as.data.frame(t(os.summary[,-1]))
colnames(tos.summary) <- os.summary$site
rownames(tos.summary) = c("start as", 
                       "stop as", 
                       "periode (dagen)", 
                       "# dagen effectief as", 
                       "# events as tijdens periode", 
                       "# events as per dag", 
                       "mediaan duur event as (min)", 
                       "mediaan duur as per dag (min)", 
                       "totale duur as periode (min)", 
                       "verwachte # glasaal per as event", 
                       "verwachte # glasaal periode")

tos.summary %>% kable(caption = "2023 beleidstabel voor het aangepast spuibeheer (as) in het afleidingskanaal van de Leie (AKL), Ijzer, kanaal Gent-Oostende (KGO), Leopoldskanaal (LK), Noordede (NE) en Veurne-Ambacht (VA) met inschatting van het aantal glasaal dat de betreffende sluizen kon passeren dankzij as. * Het verwachte aantal glasaal voor de studieperiode in VA geeft het totaal van 2023 weer en is niet dus gelinkt aan het aantal as events.") %>% kable_styling(latex_options = "scale_down")
write.csv(tos.summary,"./data/spuibeheer/intern/as_summary_2023.csv")
```

```{r}
os.summary <- os %>% 
  dplyr::filter(jaar == 2024 & datum < as.POSIXct("2024-05-15 12:00:00", tz = "Europe/Brussels")) %>% 
  group_by(site) %>%
  summarize(start = as.Date(min(open)),
            stop = as.Date(max(dicht)),
            periode = as.numeric(round(stop - start)),
            aantal.dagen.effectief.os = n_distinct(datum),
            events = n(),
            events.per.dag = round(events/aantal.dagen.effectief.os, digits = 2),
            mediaan.duur.per.event = as.numeric(round(median(duration))),
            mediaan.duur.per.dag = round(mediaan.duur.per.event * events.per.dag),
            totale.duur.os = round(as.numeric(sum(duration))),
            glasaal.per.event = round(mean(glasaal)),
            glasaal.totaal = round(sum(glasaal)))
os.summary$glasaal.totaal[which(os.summary$site == "VA")] = "176649*"
os.summary$start <- format(strptime(as.character(as.Date(os.summary$start)), "%Y-%m-%d"), "%d-%m-%Y")
os.summary$stop <- format(strptime(as.character(as.Date(os.summary$stop)), "%Y-%m-%d"), "%d-%m-%Y")
tos.summary <- as.data.frame(t(os.summary[,-1]))
colnames(tos.summary) <- os.summary$site
rownames(tos.summary) = c("start as", 
                       "stop as", 
                       "periode (dagen)", 
                       "# dagen effectief as", 
                       "# events as tijdens periode", 
                       "# events as per dag", 
                       "mediaan duur event as (min)", 
                       "mediaan duur as per dag (min)", 
                       "totale duur as periode (min)", 
                       "verwachte # glasaal per as event", 
                       "verwachte # glasaal periode")

tos.summary %>% kable(caption = "2024 beleidstabel voor het aangepast spuibeheer (as) in het afleidingskanaal van de Leie (AKL), Ijzer, kanaal Gent-Oostende (KGO), Leopoldskanaal (LK), Noordede (NE) en Veurne-Ambacht (VA) met inschatting van het aantal glasaal dat de betreffende sluizen kon passeren dankzij as. * Het verwachte aantal glasaal voor de studieperiode in VA geeft het totaal van 2024 weer en is niet dus gelinkt aan het aantal as events. Het aangepast spuibeheer in VA werd verder toegepast tot 28/6/2024 maar leverde slechts 2865 extra glasalen (1.6 %) op omdat de grootste migratire reeds had plaatsgevonden.") %>% kable_styling(latex_options = "scale_down")
write.csv(tos.summary,"./data/spuibeheer/intern/as_summary_2024.csv")
```

\pagebreak

```{r}
files <- list.files(path="./data/debiet/",pattern = ".csv")
for (i in 1:length(files)){
  path<-paste0("./data/debiet/",files[i])
  file_name<-gsub(".csv","",files[i])
  temp<-read.csv(path,sep=';',skip=8)[,1:2]
  colnames(temp)<-c("date","value")
  temp$loc.debiet<-str_split_1(file_name,"_")[1]
  temp$site.debiet<-str_split_1(file_name,"_")[2]
  temp$debiet<-as.numeric(sub(",", ".", temp$value, fixed = TRUE))
  if (i==1){debiet=temp} else {debiet=rbind(debiet,temp)}
}

debiet$date=substr(gsub("T", " ", as.character(debiet$date)),1,19)
debiet$date_brussels = as.POSIXct(debiet$date,format='%Y-%m-%d %H:%M:%S',tz="Europe/Brussels")
debiet$datum.debiet = debiet$date_brussels; attr(debiet$datum.debiet, "tzone") <- "GMT"
debiet <- debiet %>% dplyr::select(-date, -date_brussels, -value)

remove(files,path,file_name,temp)
```

```{r eval=FALSE, tijdsreeksen, fig.height=10, fig.width=10, fig.cap="Overzicht van metingen van afvoer (m³/s) voor relevante meetstations doorheen de tijd"}
ggplot(debiet, aes(x = datum.debiet, y = debiet)) + 
  geom_line() +
  xlab("Datum") + ylab("Waarde") +
  facet_wrap(~ loc.debiet,scales="free_y") + 
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1)) +
  scale_x_datetime(date_labels = "%d-%m-%Y", date_breaks = "6 months") 
```

\pagebreak

## CTD

CTD werden geplaatst op deze locaties: [link](https://rpubs.com/spbruneel-INBO/1170130).

```{r message=FALSE, error=FALSE, warning=FALSE, include=FALSE}
path="./data/ctd/"
jaren<-list.files(path=path)
counter=0
for (i in jaren){
  dir.name1<-paste0(path,i,"/")
  gebied<-list.files(path=dir.name1)
  for (j in gebied){
    dir.name2<-paste0(dir.name1,j,"/")
    dagen<-list.files(path=dir.name2)
    for (k in dagen){
      dir.name3<-paste0(dir.name2,k,"/")
      files<-list.files(path=dir.name3)
      for (l in files){
        dir.name4<-paste0(dir.name3,l)
        counter=counter+1
        if("try-error" %in% class(try(read.csv(dir.name4)))){
          ctd.temp<-read.csv(dir.name4,skip=1)[,c(2:4)]
          colnames(ctd.temp)<-c("datum.ctd","temperatuur","geleidbaarheid")
          ctd.temp$datum.ctd<-parse_date_time(ctd.temp$datum.ctd, c("mdy HMS p"))
          ctd.temp$sensor<-"small header"
        } else{
          ctd.temp<-read.csv(dir.name4,skip=65,sep=";",header=FALSE)
          ctd.temp<-ctd.temp[-nrow(ctd.temp),]
          colnames(ctd.temp)<-c("datum.ctd","druk","temperatuur","geleidbaarheid")
          ctd.temp<-as.data.frame(lapply(ctd.temp, function(y) gsub(",", ".", y)))
          ctd.temp$datum.ctd<-parse_date_time(ctd.temp$datum.ctd, c("ymd HMS"))
          ctd.temp$sensor<-"large header"
        }
        ctd.temp$site<-j
        ctd.temp$retrieval<-k
        ctd.temp$filename<-tolower(l)
        if (counter==1){ctd=ctd.temp} else{ctd=smartbind(ctd,ctd.temp)}
      }
    }
  }
}
remove(ctd.temp)
```

```{r}
ctd$datum.ctd<-as.POSIXct(ctd$datum.ctd,format='%Y-%m-%d %H:%M:%S')
ctd[c("druk","temperatuur","geleidbaarheid")] <- sapply(ctd[c("druk","temperatuur","geleidbaarheid")],as.numeric)
ctd <- ctd %>% distinct()
ctd <- ctd %>% mutate(loc.ctd= case_when(str_detect(filename, 'akl ramskapelle|akl rampskapelle') ~ 'akl ramskapelle',
                                   str_detect(filename, 'lk ramskapelle|lk rampskapelle') ~ 'lk ramskapelle',
                                   str_detect(filename, 'akl moerkerke') ~ 'akl moerkerke',
                                   str_detect(filename, 'sk zeebrugge|schipdonkkanaal_zeebrugge') ~ 'sk zeebrugge',
                                   str_detect(filename, 'blinker moerkerke') ~ 'blinker moerkerke',
                                   str_detect(filename, 'diksmuide') ~ 'diksmuide',
                                   str_detect(filename, 'schoorbakkebrug') ~ 'schoorbakkebrug',
                                   str_detect(filename, 'tervate') ~ 'tervate',
                                   str_detect(filename, 'uniebrug') ~ 'uniebrug',
                                   str_detect(filename, 'yserstar') ~ 'yserstar',
                                   str_detect(filename, 'nieuwpoort-plassendale|nieuwpoort_plassendal') ~ 'nieuwpoort-plassendale',
                                   str_detect(filename, 'brugge') ~ 'brugge',
                                   str_detect(filename, 'plassendale') ~ 'plassendale',
                                   str_detect(filename, 'sas slijkens') ~ 'sas slijkens',
                                   str_detect(filename, 'oude_veurne_vaart') ~ 'oude veurne vaart',
                                   str_detect(filename, 'blauwe sluis') ~ 'blauwe sluis',
                                   str_detect(filename, 'maertensas') ~ 'maertensas',
                                   str_detect(filename, 'clemensheule') ~ 'clemensheule'
                                   ))
```

```{r}
link.ctd.debiet<-read.csv("./data/link_debiet_ctd.csv",sep=";")
ctd<-left_join(ctd,link.ctd.debiet,by="loc.ctd")
ctd$datum.debiet<-round_date(ctd$datum.ctd, unit="15 mins")
ctd <- left_join(ctd,debiet, by=c("loc.debiet","datum.debiet"),relationship = "many-to-many")
```

```{r eval=FALSE}
k=0
for (i in unique(ctd$loc.ctd)){
  k=k+1
  ctd.temp=ctd[which(ctd$loc.ctd==i),]
  max_cond <- max(ctd.temp$geleidbaarheid,na.rm=TRUE)
  min_cond <- min(ctd.temp$geleidbaarheid,na.rm=TRUE)
  
  cond_df <- ctd.temp %>%
    dplyr::select(geleidbaarheid, datum.ctd) %>%
    rename("value_raw" = geleidbaarheid) %>%
    mutate(meting = "conductiviteit",na.rm=TRUE) %>%
    mutate(value = (value_raw - min_cond) / ((max_cond - min_cond)  / 5),na.rm=TRUE)
  
  debiet_df <- ctd.temp %>%
    dplyr::select(debiet, datum.ctd) %>%
    rename("value" = debiet) %>%
    mutate(meting = "debiet")
  
  df<-bind_rows(cond_df, debiet_df) %>%
    mutate(meting = factor(meting, levels = c("debiet", "conductiviteit"))) 
  
  g<-ggplot(df) +
      annotate("rect", xmin = as.POSIXct("2023-03-01 00:00:00"),
                    xmax = as.POSIXct("2023-05-26 00:00:00"),
                    ymin = -Inf, ymax = Inf,
                fill = "orange", alpha = 0.3) +
      geom_line(aes(x = datum.ctd, y = value, colour = meting)) +
      scale_y_continuous(name = "Debiet (m³/s)",
                         sec.axis = sec_axis(~ . * ((max_cond - min_cond) / 5)
                                             + min_cond,
                                             name = "Waterhoogte (mTAW)")) +
      scale_color_manual(breaks = c("debiet", "conductiviteit"),
                         values = c("debiet" = "lightcyan3",
                                    "conductiviteit" = "red")) +
  
      labs(title = "Waterhoogte en conductiviteit Maertensas 2022", x = "",
           colour = "") +
      theme_bw() +
      theme(
        legend.position='top', 
        legend.justification='left',
        legend.direction='horizontal'
      )
}
```

```{r}
ctd.long <- ctd %>% pivot_longer(cols=where(is.numeric),names_to="parameter",values_to="value")
k=0
p.list<-list()
for (i in unique(ctd$loc.ctd)){
  k=k+1
  p.list[[k]]<-ggplot(ctd.long[which(ctd.long$loc.ctd==i),], aes(x = datum.ctd, y = value)) + 
  geom_line() + geom_smooth() +
  annotate("rect", xmin = as.POSIXct("2023-03-01 00:00:00"), xmax = as.POSIXct("2023-05-26 00:00:00"), ymin = -Inf, ymax = Inf, fill = "orange", alpha = 0.3) +
  xlab("Datum") + ylab("Waarde") +
  facet_wrap(~ parameter,scales="free_y") + 
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1)) +
  scale_x_datetime(limits=c(as.POSIXct("2023-02-01 00:00:00"), as.POSIXct("2023-07-01 00:00:00")),date_labels = "%d-%m-%Y", date_breaks = "1 month") + ggtitle(i)
}
names(p.list)=unique(ctd$loc.ctd)
```

### Afleidingskanaal van de Leie

```{r plotaklm, fig.cap="Verloop van de conductiviteit in het afleidingskanaal van de Leie (AKL) ter hoogte van Moerkerke en debiet ter hoogte van Zomergem in 2023"}
p.list$`akl moerkerke`
```

```{r plotaklr, fig.cap="Verloop van de conductiviteit in het afleidingskanaal van de Leie (AKL) ter hoogte van Ramskapelle en debiet ter hoogte van Zomergem in 2023"}
p.list$`akl ramskapelle`
```

### Leopoldskanaal

```{r plotlkz, fig.cap="Verloop van de conductiviteit in het Leopoldskanaal (LK) ter hoogte van Zeebrugge en debiet ter hoogte van Damme in 2023"}
p.list$`sk zeebrugge`
```

```{r plotlkm, fig.cap="Verloop van de conductiviteit in het Leopoldskanaal (LK) ter hoogte van Moerkerke en debiet ter hoogte van Damme in 2023"}
p.list$`blinker moerkerke`
```

```{r plotlkr, fig.cap="Verloop van de conductiviteit in het Leopoldskanaal (LK) ter hoogte van Ramskapelle en debiet ter hoogte van Damme in 2023"}
p.list$`lk ramskapelle`
```

### Kanaal Gent-Oostende

```{r plotkgoss, fig.cap="Verloop van de conductiviteit in het kanaal Gent-Oostende (KGO) ter hoogte van sas Slijkens en debiet ter hoogte van Oostkamp in 2023"}
p.list$`sas slijkens`
```

```{r plotkgop, fig.cap="Verloop van de conductiviteit in het kanaal Gent-Oostende (KGO) ter hoogte van Plassendale en debiet ter hoogte van Oostkamp in 2023"}
p.list$plassendale
```

```{r plotkgob, fig.cap="Verloop van de conductiviteit in het kanaal Gent-Oostende (KGO) ter hoogte van Brugge en debiet ter hoogte van Oostkamp in 2023"}
p.list$brugge
```

### Ijzer

```{r plotijzery, fig.cap="Verloop van de conductiviteit in de Ijzer ter hoogte van de Yserstar en debiet ter hoogte van Keiem in 2023"}
p.list$yserstar
```

```{r plotijzeru, fig.cap="Verloop van de conductiviteit in de Ijzer ter hoogte van de Uniebrug en debiet ter hoogte van Keiem in 2023"}
p.list$uniebrug
```

```{r plotijzers, fig.cap="Verloop van de conductiviteit in de Ijzer ter hoogte van de Schoorbakkebrug en debiet ter hoogte van Keiem in 2023"}
p.list$schoorbakkebrug
```

```{r plotijzert, fig.cap="Verloop van de conductiviteit in de Ijzer ter hoogte van Tervate en debiet ter hoogte van Keiem in 2023"}
p.list$tervate
```

```{r plotijzerd, fig.cap="Verloop van de conductiviteit in de Ijzer ter hoogte van Diskmuide en debiet ter hoogte van Keiem in 2023"}
p.list$diksmuide
```

### Kanaal Nieuwpoort-Plasendale

```{r plotknp, fig.cap="Verloop van de conductiviteit in het kanaal Nieuwpoort-Plassendale ter hoogte van Nieuwpoort-Plassendale en debiet ter hoogte van Keiem in 2023"}
p.list$`nieuwpoort-plassendale`
```

### Kanaal Nieuwpoort-Duinkerke

```{r plotknd, fig.cap="Verloop van de conductiviteit in het kanaal Nieuwpoort-Duinkerke ter hoogte van de oude Veurne vaart en debiet ter hoogte van Veurne in 2023"}
p.list$`oude veurne vaart`
```

### Noordede

```{r plotnem, fig.cap="Verloop van de conductiviteit in de Noordede (NE) ter hoogte van de Maertensas en debiet ter hoogte van Oostkamp in 2023"}
p.list$maertensas
```

```{r plotnebs, fig.cap="Verloop van de conductiviteit in de Noordede (NE) ter hoogte van de blauwe sluis en debiet ter hoogte van Oostkamp in 2023"}
p.list$`blauwe sluis`
```

```{r plotnec, fig.cap="Verloop van de conductiviteit in de Noordede (NE) ter hoogte van Clemensheule en debiet ter hoogte van Oostkamp in 2023"}
p.list$clemensheule
```
